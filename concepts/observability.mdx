---
title: "Observability"
description: "Why AI agent traffic is invisible to traditional analytics, and how AgentReady makes it visible."
---

## Why Observability Matters

There's a blind spot in every analytics dashboard: AI agent traffic. Agents don't execute JavaScript, don't load tracking pixels, and don't trigger page view events. Google Analytics, Plausible, Fathom, PostHog — none of them see this traffic. Your site might be getting crawled by GPTBot hundreds of times a day, and you'd never know.

This matters because AI agent traffic is growing rapidly, and it influences whether your content gets cited, recommended, or surfaced in AI-generated answers. Understanding this traffic is the first step to optimizing for it.

AgentReady logs every agent request with zero impact on response latency, giving you visibility into:

- **Which agents** are crawling your site (GPTBot, ClaudeBot, PerplexityBot, etc.)
- **Which pages** they visit most frequently
- **Response performance** — latency, size, cache hit rate
- **Token savings** — how many tokens you're saving per request
- **Trends** — is your agent traffic growing? Which agents are new?

## How Logging Works

AgentReady uses `waitUntil()` to fire analytics events **after** the response is sent to the agent. The agent gets their markdown immediately — logging happens in the background.

```typescript
// Inside withAgentServing — simplified
const response = new Response(markdown, { headers });

// Fire-and-forget analytics (non-blocking)
request.waitUntil(
  trackAgentRequest({
    path: pathname,
    agent: classifiedAgent,
    method: detectionMethod,     // 'accept-header' or 'user-agent'
    responseSize: markdown.length,
    htmlSize: html.length,
    latencyMs: Date.now() - start,
    locale: detectedLocale,
    cached: wasCached,
    timestamp: new Date().toISOString(),
  })
);

return response;
```

**Latency impact: zero.** The response is returned before logging begins.

Why `waitUntil()` instead of a synchronous log? Because the agent's experience comes first. An agent requesting your pricing page needs the markdown — it doesn't need to wait for your analytics pipeline. `waitUntil()` is a Vercel/Cloudflare primitive that lets the response go out immediately while the logging runs in the same serverless invocation. The function stays alive long enough to complete the log, but the agent is already reading your content.

## Event Schema

Each agent request generates an event with the following fields:

| Field | Type | Description |
|---|---|---|
| `path` | string | The requested URL path |
| `agent` | string | Classified agent name (e.g., "GPTBot") |
| `method` | string | Detection method: `accept-header` or `user-agent` |
| `ipVerified` | boolean | Whether the IP matches the agent's published ranges |
| `responseSize` | number | Markdown response size in bytes |
| `htmlSize` | number | Original HTML size in bytes |
| `tokensSaved` | number | Estimated tokens saved (based on 4 chars/token) |
| `latencyMs` | number | End-to-end conversion time in milliseconds |
| `locale` | string | Detected locale (if i18n is configured) |
| `cached` | boolean | Whether the markdown was served from cache |
| `statusCode` | number | HTTP status code returned |
| `timestamp` | string | ISO 8601 timestamp |

## Free Tier vs Dashboard

### Free Tier (No Project ID)

Without a project ID, AgentReady still works — it serves markdown and generates llms.txt. But there's no logging. You get the optimization without the visibility.

### Dashboard ($29/month)

With a project ID, events flow to the AgentReady dashboard where you get:

- Real-time agent traffic overview
- Per-page analytics
- Agent breakdown (pie chart of traffic by agent type)
- Token savings calculator
- Latency monitoring
- Alerting (new agent detected, traffic spikes, errors)
- CSV/API export

See the [Dashboard Overview](/dashboard/overview) for details.

## Self-Hosted Analytics

If you prefer to keep data in-house, AgentReady supports custom event handlers:

```typescript
withAgentServing(request, {
  onAgentRequest: async (event) => {
    // Send to your own analytics pipeline
    await clickhouse.insert({
      table: 'agent_requests',
      values: [event],
    });
  },
});
```

This replaces the default AgentReady API logging. You get full control over where data goes — ClickHouse, BigQuery, PostgreSQL, your own API, whatever you want.

## What You Can Learn

Common insights from the dashboard:

- "GPTBot visits our /pricing page 3x more than any other page"
- "ClaudeBot traffic increased 40% after we added content negotiation"
- "PerplexityBot only crawls pages linked from our llms.txt"
- "We're saving $1,800/month in estimated token costs across all agents"
- "A new agent (Gemini-1.5) started crawling us last Tuesday"

This data informs decisions about content optimization, agent-specific customization, and whether to invest in features like [A/B testing](/guides/ab-testing).
